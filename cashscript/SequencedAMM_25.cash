pragma cashscript ^0.11.0;  // Current version as of July 2025

contract SequencedAMM(bytes32 poolId, int initialK, bytes20 tokenCategory) {
    // Commit: Append hash to commitment (OP_CAT enabled since 2018).
    function commit(bytes32 actionHash) {
        require(tx.outputs[0].lockingBytecode == this.activeBytecode);
        require(tx.outputs[0].tokenCategory == tokenCategory);
        bytes currentCommitment = tx.inputs[0].nftCommitment;
        bytes newCommitment = cat(currentCommitment, actionHash);  // OP_CAT for append.
        bytes32 newMerkleRoot = sha256(newCommitment);  // SHA256 for root.
        require(tx.outputs[0].nftCommitment == newCommitment);
        require(tx.outputs[0].value == tx.inputs[0].value - 1000);  // Fee.
    }

    // Swap: Sequence with OP_CAT, extract with OP_SPLIT (manual for 8 bytes).
    function swap(int inputAmount, bool isBCHInput, bytes32 commitHash) {
        require(tx.inputs[1].outpointTransaction == commitHash);  // Basic introspection.

        bytes sequencedInputs = cat(tx.inputs[0].value, tx.inputs[1].value);  // OP_CAT.
        sequencedInputs = cat(sequencedInputs, bytes8(inputAmount));
        bytes32 merkleRoot = sha256(sequencedInputs);

        bytes currentCommitment = tx.inputs[0].nftCommitment;
        // Manual split for reserves (using OP_SPLIT equivalents; unrolled for fixed 8 bytes).
        bytes bchBytes = currentCommitment OP_SPLIT(8)[0];  // First 8 bytes.
        bytes tokenBytes = currentCommitment OP_SPLIT(8)[1];  // Next 8.
        int poolBCH = int(bchBytes);
        int poolTokens = int(tokenBytes);

        int newPoolBCH = isBCHInput ? poolBCH + inputAmount : poolBCH - inputAmount;
        int newPoolTokens = initialK / newPoolBCH;
        int outputAmount = isBCHInput ? poolTokens - newPoolTokens : newPoolTokens - poolTokens;

        require(tx.outputs.length == 2);
        require(tx.outputs[0].value == outputAmount);
        require(tx.outputs[1].lockingBytecode == this.activeBytecode);  // Recursion.
        require(tx.outputs[1].value == newPoolBCH);
        require(tx.outputs[1].tokenAmount == newPoolTokens);
        require(tx.outputs[1].tokenCategory == tokenCategory);

        bytes newCommitment = cat(bytes8(newPoolBCH), bytes8(newPoolTokens));
        newCommitment = cat(newCommitment, merkleRoot);
        require(tx.outputs[1].nftCommitment == newCommitment);

        require(checkDataSig(merkleRoot, tx.preimage));  // Partial preimage bind (sighash).

        int minerFee = 2000;
        require(tx.inputs[0].value + inputAmount >= newPoolBCH + outputAmount + minerFee);
    }

    // Withdrawal: As-is, fully possible today.
    function withdraw(pubkey lpPk, sig lpSig) {
        require(checkSig(lpSig, lpPk));
        require(tx.outputs[0].lockingBytecode == new LockingBytecodeP2PKH(hash160(lpPk)));
        require(tx.outputs[0].value == tx.inputs[0].value - 1000);
        require(tx.outputs[0].tokenAmount == tx.inputs[0].tokenAmount);
        require(tx.outputs[0].nftTokenAmount == 0);  // Burn NFT.
    }
}